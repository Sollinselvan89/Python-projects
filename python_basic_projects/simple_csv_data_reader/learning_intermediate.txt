Here you go â€” **a clean, printable one-page cheat sheet** of the *Universal Data Cleaning Framework* (general principles you wanted), followed by the **rest of the items you asked for**:

* ğŸ”¹ 10 most useful `os` / `os.path` functions
* ğŸ”¹ One-page cheat sheet on Lists vs Sets vs Tuples vs Dicts

All in one place.
No Q&A.
Only pure distilled knowledge.

---

# ğŸ“„ **ONE-PAGE DATA CLEANING CHEAT-SHEET (UNIVERSAL PRINCIPLES)**

### *Use this for ANY data-cleaning task, in any project, any language.*

---

# â­ **1. Understand the Data (Before Coding)**

* Identify each field and its meaning
* Understand formats (dates? names? numbers?)
* Know required vs optional fields
* Know the valid ranges, formats, and constraints

**â†’ Never write code until you understand the data structure.**

---

# â­ **2. Define Rules Per Field (The Rulebook)**

For each column, define:

* **Valid** â†’ Acceptable and normal
* **Warning** â†’ Missing or unusual but usable
* **Invalid** â†’ Impossible or structurally broken

**â†’ Rules guide every decision in cleaning.**

---

# â­ **3. Normalize Before Validating**

Normalization standardizes messy input:

* trim spaces
* lowercase/uppercase
* collapse multiple spaces
* convert words to numbers
* standardize separators

**â†’ Clean the data FIRST, then validate the cleaned version.**

---

# â­ **4. One Function Per Field (Modular Design)**

Example:

* `normalize_name()`
* `normalize_age()`
* `normalize_email()`

Each function should return:

```
(cleaned_value, status)
```

Where status âˆˆ `{"ok", "warning", "invalid"}`.

**â†’ Small single-purpose functions give clean architecture.**

---

# â­ **5. Combine All Field Results â†’ Determine Row Status**

Hierarchy:

1. **invalid** â†’ if ANY invalid field
2. **warning** â†’ if no invalid fields, but any warning
3. **clean** â†’ if all fields ok

**â†’ Every row gets a clear classification.**

---

# â­ **6. Keep Raw Data for Invalid Rows**

Never use cleaned values for invalid rows.

* raw values help debug
* raw values preserve original mistakes
* raw values are the â€œsource of truthâ€

**â†’ Invalid rows must be traceable.**

---

# â­ **7. Always Output in Three Buckets**

* **cleaned.csv**
* **warnings.csv**
* **invalid.csv**

Consistent headers.
Consistent formatting.

**â†’ Organization is essential in data engineering.**

---

# â­ **8. Build a Clear Data-Cleaning Pipeline**

Order:

1. Input file
2. Preprocess text
3. Tokenize rows
4. Normalize fields
5. Validate fields
6. Classify rows (clean/warn/invalid)
7. Write output files
8. Summary of results

**â†’ Every data-cleaning script follows this 8-step pipeline.**

---

# â­ **9. Maintain Clarity with Type Annotations**

Annotate everything:

```python
def normalize_age(age: str) -> tuple[int | None, str]:
```

**â†’ Type clarity = fewer bugs + better thinking.**

---

# â­ **10. Error Tolerance Rule**

Only things that truly break meaning are **invalid**.
Everything else is a **warning**.

**â†’ Aim for robustness, not perfection.**

---

# ğŸ“„ END OF ONE-PAGE CHEAT SHEET

---

Now, the rest of what you asked for:

---

# ğŸ“Œ **10 MOST USEFUL `os` & `os.path` FUNCTIONS (BEGINNER EDITION)**

### âœ” File system navigation

* `os.getcwd()` â†’ get current working directory
* `os.listdir(path)` â†’ list files/folders
* `os.chdir(path)` â†’ change directory

### âœ” File/Folder checks

* `os.path.exists(path)` â†’ path exists?
* `os.path.isfile(path)` â†’ is file?
* `os.path.isdir(path)` â†’ is directory?

### âœ” Path manipulation

* `os.path.join(a, b)` â†’ safe path builder
* `os.path.abspath(path)` â†’ absolute path

### âœ” File operations

* `os.remove(path)` â†’ delete file
* `os.makedirs(path, exist_ok=True)` â†’ create folder(s)

---

# ğŸ“Œ **LISTS vs SETS vs TUPLES vs DICTS (CHEAT SHEET)**

### ğŸ”¹ **LIST**

* Ordered
* Mutable
* Allows duplicates
* Indexable (`lst[0]`)
* Use when order matters

Example:

```python
["Alice", "Bob", "Charlie"]
```

---

### ğŸ”¹ **TUPLE**

* Ordered
* **Immutable**
* Allows duplicates
* Faster than lists
* Use for *fixed* data

Example:

```python
("x", "y")
```

---

### ğŸ”¹ **SET**

* Unordered
* Unique elements only
* Very fast membership checks
* No duplicates

Example:

```python
{"apple", "banana", "apple"}  # becomes {"apple", "banana"}
```

---

### ğŸ”¹ **DICTIONARY**

* Keyâ€“value pairs
* Keys must be unique
* Fast lookup of values
* Ideal for structured data

Example:

```python
{"name": "Alice", "age": 14}
```

---

# ğŸ‰ Everything you asked for is now delivered:

### âœ” One-page Data Cleaning cheat-sheet

### âœ” os / os.path mini cheat-sheet

### âœ” Lists vs Sets vs Tuples vs Dicts cheat-sheet

### âœ” All content distilled into pure learning

### âœ” No Q&A format

